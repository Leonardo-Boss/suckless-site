diff --cc config.def.h
index 35060d7,6ea816b..0000000
--- a/config.def.h
+++ b/config.def.h
@@@ -135,10 -135,16 +135,16 @@@ static unsigned int defaultunderline = 
   * Internal mouse shortcuts.
   * Beware that overloading Button1 will disable the selection.
   */
 -static Mousekey mkeys[] = {
 +static MouseShortcut mshortcuts[] = {
  	/* button               mask            string */
- 	{ Button4,              XK_ANY_MOD,     "\031" },
- 	{ Button5,              XK_ANY_MOD,     "\005" },
+ 	{ Button4,              XK_NO_MOD,      "\031" },
+ 	{ Button5,              XK_NO_MOD,      "\005" },
+ };
+ 
 -static MouseShortcut mshortcuts[] = {
++static MouseKey mkeys[] = {
+ 	/* button               mask            function        argument */
+ 	{ Button4,              ShiftMask,      kscrollup,      { .i = 1 } },
+ 	{ Button5,              ShiftMask,      kscrolldown,    { .i = 1 } },
  };
  
  /* Internal keyboard shortcuts. */
diff --git a/st.c b/st.c
index 00ea0dc..91d4230 100644
--- a/st.c
+++ b/st.c
@@ -326,7 +326,7 @@ typedef struct {
 	uint mask;
 	void (*func)(const Arg *);
 	const Arg arg;
-} MouseShortcut;
+} MouseKey;
 
 typedef struct {
 	uint mod;
@@ -959,6 +959,7 @@ bpress(XEvent *e)
 {
 	struct timespec now;
 	MouseShortcut *ms;
+	MouseKey *mk;
 
 	if (IS_SET(MODE_MOUSE) && !(e->xbutton.state & forceselmod)) {
 		mousereport(e);
@@ -973,10 +974,10 @@ bpress(XEvent *e)
 		}
 	}
 
-	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
-		if (e->xbutton.button == ms->b
-				&& match(ms->mask, e->xbutton.state)) {
-			ms->func(&ms->arg);
+	for (mk = mkeys; mk < mkeys + LEN(mkeys); mk++) {
+		if (e->xbutton.button == mk->b
+				&& match(mk->mask, e->xbutton.state)) {
+			mk->func(&mk->arg);
 			return;
 		}
 	}
