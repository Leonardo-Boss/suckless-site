From 63ed18e9ee236bb88426fddee2d311e090aee71d Mon Sep 17 00:00:00 2001
From: Gan Ainm <gan.ainm.riomhphost@gmail.com>
Date: Tue, 9 Jun 2020 16:03:30 +0000
Subject: [PATCH] Make autostart patch XDG conformant

---
 dwm.c | 92 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 92 insertions(+)

diff --git a/dwm.c b/dwm.c
index 4465af1..ac6ed5e 100644
--- a/dwm.c
+++ b/dwm.c
@@ -29,6 +29,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
 #include <X11/cursorfont.h>
 #include <X11/keysym.h>
@@ -193,6 +194,7 @@ static void resizeclient(Client *c, int x, int y, int w, int h);
 static void resizemouse(const Arg *arg);
 static void restack(Monitor *m);
 static void run(void);
+static void runautostart(void);
 static void scan(void);
 static int sendevent(Client *c, Atom proto);
 static void sendmon(Client *c, Monitor *m);
@@ -235,7 +237,11 @@ static int xerrorstart(Display *dpy, XErrorEvent *ee);
 static void zoom(const Arg *arg);
 
 /* variables */
+static const char autostartblocksh[] = "autostart_blocking.sh";
+static const char autostartsh[] = "autostart.sh";
 static const char broken[] = "broken";
+static const char dwmdir[] = "dwm";
+static const char localshare[] = ".local/share";
 static char stext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
@@ -1380,6 +1386,91 @@ run(void)
 			handler[ev.type](&ev); /* call handler */
 }
 
+void
+runautostart(void)
+{
+	char *pathpfx;
+	char *path;
+	char *xdgdatahome;
+	char *home;
+
+	if ((home = getenv("HOME")) == NULL)
+		/* this is almost impossible */
+		return;
+
+	/* if $XDG_DATA_HOME is defined, use $XDG_DATA_HOME/dwm,
+	 * otherwise use ~/.local/share/dwm as autostart script directory
+	 */
+	if ((xdgdatahome = getenv("XDG_DATA_HOME")) != NULL) {
+		/* space for path segments, separators and nul */
+		if ((pathpfx = malloc(strlen(xdgdatahome) + strlen(dwmdir) + 2)) == NULL)
+			return;
+
+		if (sprintf(pathpfx, "%s/%s", xdgdatahome, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	} else {
+		/* space for path segments, separators and nul */
+		if ((pathpfx = malloc(strlen(home) + strlen(localshare) + strlen(dwmdir) + 3)) == NULL)
+			return;
+
+		if (sprintf(pathpfx, "%s/%s/%s", home, localshare, dwmdir) < 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* check if the autostart script directory exists */
+	struct stat sb;
+
+	if (! (stat(pathpfx, &sb) == 0 && S_ISDIR(sb.st_mode))) {
+		/* the XDG conformant path does not exist or are not directories
+		 * so we try ~/.dwm instead
+		 */
+		if (realloc(pathpfx, strlen(home) + strlen(dwmdir) + 3) == NULL) {
+			free(pathpfx);
+			return;
+		}
+
+		if (sprintf(pathpfx, "%s/.%s", home, dwmdir) <= 0) {
+			free(pathpfx);
+			return;
+		}
+	}
+
+	/* try the blocking script first */
+	if ((path = malloc(strlen(pathpfx) + strlen(autostartblocksh) + 2)) == NULL) {
+		free(pathpfx);
+		return;
+	} else
+		if (sprintf(path, "%s/%s", pathpfx, autostartblocksh) <= 0) {
+			free(path);
+			free(pathpfx);
+		}
+
+	if (access(path, X_OK) == 0) {
+		system(path);
+	}
+
+	/* now the non-blocking script */
+	if ((path = realloc(path, strlen(pathpfx) + strlen(autostartsh) + 4)) == NULL) {
+		free(pathpfx);
+		free(path);
+		return;
+	} else
+		if (sprintf(path, "%s/%s", pathpfx, autostartsh) <= 0) {
+			free(path);
+			free(pathpfx);
+		}
+
+	if (access(path, X_OK) == 0) {
+		system(strcat(path, " &"));
+		free(pathpfx);
+		free(path);
+	}
+}
+
 void
 scan(void)
 {
@@ -2142,6 +2233,7 @@ main(int argc, char *argv[])
 		die("pledge");
 #endif /* __OpenBSD__ */
 	scan();
+	runautostart();
 	run();
 	cleanup();
 	XCloseDisplay(dpy);
-- 
2.27.0

