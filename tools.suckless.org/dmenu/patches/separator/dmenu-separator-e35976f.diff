diff --git a/dmenu.1 b/dmenu.1
index 323f93c..d511148 100644
--- a/dmenu.1
+++ b/dmenu.1
@@ -22,6 +22,10 @@ dmenu \- dynamic menu
 .IR color ]
 .RB [ \-w
 .IR windowid ]
+.RB [ \-d
+.IR separator ]
+.RB [ \-D
+.IR separator ]
 .P
 .BR dmenu_run " ..."
 .SH DESCRIPTION
@@ -80,6 +84,14 @@ prints version information to stdout, then exits.
 .TP
 .BI \-w " windowid"
 embed into windowid.
+.TP
+.BI \-d " separator"
+separate the input into two halves on the first occurrence of the given charcter.
+Display only the first half in dmenu and print the second half to stdout upon selection.
+Appending '|' to the separator reverses the display/printing order.
+.TP
+.BI \-D " separator"
+same as \-d but separate based on the last occurrence.
 .SH USAGE
 dmenu is completely controlled by the keyboard.  Items are selected using the
 arrow keys, page up, page down, home, and end.
diff --git a/dmenu.c b/dmenu.c
index 571bc35..f2add3b 100644
--- a/dmenu.c
+++ b/dmenu.c
@@ -30,12 +30,15 @@ enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */
 
 struct item {
 	char *text;
+	char *text_output;
 	struct item *left, *right;
 	int out;
 };
 
 static char text[BUFSIZ] = "";
 static char *embed;
+static char separator, separator_reverse;
+static char * (*sepchr)(const char *, int);
 static int bh, mw, mh;
 static int inputw = 0, promptw;
 static int lrpad; /* sum of left and right padding */
@@ -105,7 +108,7 @@ cleanup(void)
 	for (i = 0; i < SchemeLast; i++)
 		free(scheme[i]);
 	for (i = 0; items && items[i].text; ++i)
-		free(items[i].text);
+		free(separator_reverse ? items[i].text_output : items[i].text);
 	free(items);
 	drw_free(drw);
 	XSync(dpy, False);
@@ -490,7 +493,7 @@ insert:
 		break;
 	case XK_Return:
 	case XK_KP_Enter:
-		puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
+		puts((sel && !(ev->state & ShiftMask)) ? sel->text_output : text);
 		if (!(ev->state & ControlMask)) {
 			cleanup();
 			exit(0);
@@ -561,6 +564,17 @@ readstdin(void)
 			*p = '\0';
 		if (!(items[i].text = strdup(buf)))
 			die("cannot strdup %zu bytes:", strlen(buf) + 1);
+		if (separator && (p = sepchr(items[i].text, separator)) != NULL) {
+			*p = '\0';
+			items[i].text_output = ++p;
+		} else {
+			items[i].text_output = items[i].text;
+		}
+		if (separator_reverse) {
+			p = items[i].text;
+			items[i].text = items[i].text_output;
+			items[i].text_output = p;
+		}
 		items[i].out = 0;
 	}
 	if (items)
@@ -711,7 +725,8 @@ static void
 usage(void)
 {
 	fputs("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
-	      "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]\n", stderr);
+	      "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]\n"
+	      "             [-d separator] [-D separator]\n", stderr);
 	exit(1);
 }
 
@@ -754,6 +769,12 @@ main(int argc, char *argv[])
 			colors[SchemeSel][ColFg] = argv[++i];
 		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
 			embed = argv[++i];
+		else if (!strcmp(argv[i], "-d") || /* field separator */
+		         !strcmp(argv[i], "-D")) {
+			sepchr = argv[i][1] == 'D' ? strrchr : strchr;
+			separator = argv[++i][0];
+			separator_reverse = argv[i][1] == '|';
+		}
 		else
 			usage();
 
